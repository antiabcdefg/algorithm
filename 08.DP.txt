//https://chengzhaoxi.xyz/42296.html

DP用于解决重叠子问题情况，保存子问题的解，避免重复计算。

1.满足以下：
  1.求最值（从左上角到右上角路径的最大数字和、最长上升子序列长度）
  2.求方案数（有多少种方式走到右下角、有多少种方法选出K个数使得和是Sum）
  3.求存在性（取石子游戏，先手是否必胜；能不能选出K个数使得和是Sum）
2.满足不能排序或者交换(128. 最长连续序列不用dp)

1.确定状态（研究最优策略的最后一步，转化为子问题  最优子结构+无后效性）
2.转移方程（根据子问题定义直接得到）
3.初始条件和边界情况
4.计算顺序（利用之前的计算结果）




1.线性DP

1.1 单串问题, 状态为 dp[i]  i 是时间或者位置

1.1.1 打家劫舍系列: 不相邻子序列的最大和问题
198. 打家劫舍
class Solution {
    public int rob(int[] nums) {
        if(nums.length==0) return 0;
        int[] dp=new int[nums.length+1];
        dp[1]=nums[0];
        for(int i=2;i<=nums.length;i++){
            dp[i]=Math.max(dp[i-2]+nums[i-1],dp[i-1]);
        }
        return dp[nums.length];
    }
}

class Solution {
    public int rob(int[] nums) {
        if(nums.length==0) return 0;
        int prev=0,cur=nums[0];
        for(int i=1;i<nums.length;i++){
            int temp=Math.max(prev+nums[i],cur);
            prev=cur;
            cur=temp;
        }
        return cur;
    }
}

213. 打家劫舍 II
class Solution {
    public int rob(int[] nums) {
        if(nums==null||nums.length==0) return 0;
        if(nums.length==1) return nums[0];
        return Math.max(robHelp(nums,0,nums.length-1),robHelp(nums,1,nums.length));
    }
    public int robHelp(int[] nums,int l,int r){
        int pre=0,cur=nums[l];
        for(int i=l+1;i<r;i++){
            int temp=Math.max(pre+nums[i],cur);
            pre=cur;
            cur=temp;
        }
        return cur;
    }
}

740. 删除与获得点数
class Solution {
    public int deleteAndEarn(int[] nums) {
        if(nums.length==0) return 0;
        if(nums.length==1) return nums[0];
        int[] cnt=new int[10001];
        for(int i:nums) cnt[i]++;

        int[] dp=new int[10001];
        dp[1]=cnt[1];
        for(int i=2;i<10001;i++){
            dp[i]=Math.max(dp[i-1],dp[i-2]+i*cnt[i]);
        }
        return dp[10000];
    }
}

1388. 3n 块披萨
//213. 打家劫舍 II 不会拿走房子，本题会拿走房子，相当于加上n/3个限制
//dp[i][j]表示[0,i]选j个的最大值
class Solution {
    public int maxSizeSlices(int[] slices) {
        return Math.max(maxSizeSlicesHelp(slices,0,slices.length-1),maxSizeSlicesHelp(slices,1,slices.length));
    }
    public int maxSizeSlicesHelp(int[] slices,int l,int r){
        int n=(r+1)/3;
        int[][] dp=new int[r+1][n+1];

        for(int i=l+1;i<=r;i++){
            for(int j=1;j<=n;j++){
                dp[i][j]=Math.max(dp[i-1][j],i>l+1?dp[i-2][j-1]+slices[i-1]:slices[i-1]);
            }
        }
        return dp[r][n];
    }
}


1.1.2 最经典单串 LIS 系列：
300. 最长上升子序列LIS
//https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/
//O(n^2) O(n)
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n=nums.length;
        int[] dp=new int[n];
         int res=0;
        for(int i=0;i<n;i++){
            dp[i]=1;
            for(int j=0;j<i;j++){
                if(nums[i]>nums[j]) dp[i]=Math.max(dp[i],dp[j]+1);
                //最长不下降子序列 if(nums[i]>=nums[j]) dp[i]=Math.max(dp[i],dp[j]+1);
                //最大上升子序列和 if(nums[i]>nums[j]) dp[i]=Math.max(dp[i],dp[j]+nums[i]);
            }
            res=Math.max(res,dp[i]);
        }
        return res;
    }
}

//O(nlog(n)) O(n)
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n=nums.length;
        if(n<=1) return n;

        int[] copy=new int[n];
        copy[0]=nums[0];
        int idx=0;
        for(int i=1;i<n;i++){
            if(nums[i]>copy[idx]) copy[++idx]=nums[i];//升序直接添加到结尾
            else copy[insert_search(copy,nums[i],idx)]=nums[i];
        }
        return idx+1;
    }
    public int insert_search(int[] copy,int target,int end){//找到添加位置
        int l=0,r=end;
        while(l<r){
            int m=l+((r-l)>>>1);
            if(copy[m]<target) l=m+1;
            else r=m;
        }
        return l;
    }
}

class Solution {
    public int lengthOfLIS(int[] nums) {
        int n=nums.length;
        if(n<=1) return n;

        int[] tails=new int[n];
        int idx=0;
        for(int i:nums){
            int l=0,r=idx;
            while(l<r){
                int m=l+((r-l)>>>1);
                if(tails[m]<i) l=m+1;
                else r=m;
            }
            tails[l]=i;
            if(idx==r) idx++;
        }
        return idx;
    }
}

//674. 最长连续递增序列
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        if(nums.length==0||nums==null) return 0;
        int res=1,cnt=1;
        for(int i=1;i<nums.length;i++){
            if(nums[i]>nums[i-1]) cnt++;
            else cnt=1;
            res=Math.max(res,cnt);
        }
        return res;
    }
}

673. 最长递增子序列的个数
class Solution {
    public int findNumberOfLIS(int[] nums) {
        int[] dp=new int[nums.length];
        int[] cnt=new int[nums.length];
        int max=0,res=0;
        for(int i=0;i<dp.length;i++){
            dp[i]=1;cnt[i]=1;
            for(int j=0;j<i;j++){
                if(nums[i]>nums[j]){
                    if(dp[j]+1>dp[i]){
                        dp[i]=dp[j]+1;
                        cnt[i]=cnt[j];
                    }else if(dp[j]+1==dp[i]) cnt[i]+=cnt[j];
                }
            }
            if(dp[i]==max) res+=cnt[i];
            else if(dp[i]>max){
                max=dp[i];
                res=cnt[i];
            }
        }
        return res;
    }
}

354. 俄罗斯套娃信封问题
class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        Arrays.sort(envelopes,(a,b)->(a[0]-b[0]));
        int[] dp=new int[envelopes.length];
        int res=0;
        for(int i=0;i<dp.length;i++){
            dp[i]=1;
            for(int j=0;j<i;j++){
                if(envelopes[i][0]>envelopes[j][0]&&envelopes[i][1]>envelopes[j][1]) dp[i]=Math.max(dp[i],dp[j]+1);
            }
            res=Math.max(res,dp[i]);
        }
        return res;
    }
}

class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        if(envelopes.length==0) return 0;
        Arrays.sort(envelopes,(a,b)->(a[0]==b[0]?b[1]-a[1]:a[0]-b[0]));
        int[] copy=new int[envelopes.length];
        copy[0]=envelopes[0][1];
        int idx=0;
        for(int i=1;i<envelopes.length;i++){
            if(envelopes[i][1]>copy[idx]) copy[++idx]=envelopes[i][1];
            else{
                int l=0,r=idx;
                while(l<r){
                    int mid=(l+r)>>>1;
                    if(copy[mid]<envelopes[i][1]) l=mid+1;
                    else r=mid;
                }
                copy[l]=envelopes[i][1];
            }
        }
        return idx+1;
    }
}

1626. 无矛盾的最佳球队
class Solution {
    public int bestTeamScore(int[] scores, int[] ages) {
        int n=scores.length;
        int[][] copy=new int[n][2];
        for(int i=0;i<n;i++){
            copy[i][0]=ages[i];
            copy[i][1]=scores[i];
        }
        Arrays.sort(copy,(a,b)->(a[0]==b[0]?a[1]-b[1]:a[0]-b[0]));

        int res=0;
        int[] dp=new int[n];
        for(int i=0;i<n;i++){
            dp[i]=copy[i][1];
            for(int j=0;j<i;j++){
                if(copy[i][1]>=copy[j][1]) dp[i]=Math.max(dp[i],dp[j]+copy[i][1]);
            }
            res=Math.max(res,dp[i]);
        }
        return res;
    }
}

1691. 堆叠长方体的最大高度
class Solution {
    public int maxHeight(int[][] cuboids) {
        for(int[] c:cuboids) Arrays.sort(c);
        Arrays.sort(cuboids,(a,b)->{
            if(a[0]!=b[0]) return Integer.compare(a[0],b[0]);
            else if(a[1]!=b[1]) return Integer.compare(a[1],b[1]);
            else return Integer.compare(a[2],b[2]);
        });
        int res=0;
        int[] dp=new int[cuboids.length];
        for(int i=0;i<cuboids.length;i++){
            dp[i]=cuboids[i][2];
            for(int j=0;j<i;j++){
                if(cuboids[j][0]<=cuboids[i][0]&&cuboids[j][1]<=cuboids[i][1]&&cuboids[j][2]<=cuboids[i][2]){
                    dp[i]=Math.max(dp[i],dp[j]+cuboids[i][2]);
                }
            }
            res=Math.max(res,dp[i]);
        }
        return res;
    }
}

960. 删列造序 III
class Solution {
    public int minDeletionSize(String[] A) {
        if(A.length==0) return 0;
        int n=A[0].length(),m=A.length;

        int[] dp=new int[n];
        int max=0;
        for(int i=0;i<n;i++){
            dp[i]=1;
            for(int j=0;j<i;j++){
                boolean isOk=true;
                for(int k=0;k<m;k++) if(A[k].charAt(i)<A[k].charAt(j)){isOk=false; break;}
                if(isOk) dp[i]=Math.max(dp[i],dp[j]+1);
            }
            max=Math.max(max,dp[i]);
        }
        return n-max;
    }
}

1048. 最长字符串链
class Solution {
    public int longestStrChain(String[] words) {
        Arrays.sort(words,(a,b)->(a.length()-b.length()));
        int[] dp=new int[words.length];
        int res=0;
        for(int i=0;i<words.length;i++){
            dp[i]=1;
            for(int j=0;j<i;j++){
                if(isSub(words[i],words[j])) dp[i]=Math.max(dp[i],dp[j]+1);
            }
            res=Math.max(res,dp[i]);
        }
        return res;
    }
    public boolean isSub(String a,String b){
        int n=a.length(),m=b.length();
        if(n!=(m+1)) return false;
        int i=0,j=0;
        while(i<n&&j<m){
            if(a.charAt(i)==b.charAt(j)) j++;
            i++;
        }
        return j==m;
    }
}

class Solution {
    public int longestStrChain(String[] words) {
        Arrays.sort(words,(a,b)->(a.length()-b.length()));
        int[] arr=new int[17];
        Arrays.fill(arr,-1);
        for(int i=0;i<words.length;i++) arr[words[i].length()]=i;

        int[] dp=new int[words.length];
        int res=0;
        for(int i=0;i<words.length;i++){
            dp[i]=1;
            int idx=arr[words[i].length()-1];
            while(idx!=-1&&words[idx].length()+1==words[i].length()){
                if(isSub(words[i],words[idx])) dp[i]=Math.max(dp[i],dp[idx]+1);
                idx--;
            }
            res=Math.max(res,dp[i]);
        }
        return res;
    }
}

646. 最长数对链
class Solution {
    public int findLongestChain(int[][] pairs) {
        Arrays.sort(pairs,(a,b)->(a[0]-b[0]));
        int[] dp=new int[pairs.length];
        int res=0;
        for(int i=0;i<pairs.length;i++){
            for(int j=0;j<i;j++){
                if(pairs[i][0]>pairs[j][1]){
                    dp[i]=Math.max(dp[i],dp[j]+1);
                    res=Math.max(res,dp[i]);
                }
            }
        }
        return res+1;
    }
}

674. 最长连续递增序列
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        if(nums.length==0||nums==null) return 0;
        int res=1,cnt=1;
        for(int i=1;i<nums.length;i++){
            if(nums[i]>nums[i-1]) cnt++;
            else cnt=1;
            res=Math.max(res,cnt);
        }
        return res;
    }
}

376. 摆动序列
//up[i]是nums[0:i]中最后两个数字递增, down[i]是nums[0:i]中最后两个数字递减
class Solution {
    public int wiggleMaxLength(int[] nums) {
        if(nums.length==0) return 0;
        int up=1,down=1;
        for(int i=1;i<nums.length;i++){
            if(nums[i]>nums[i-1]) up=down+1;
            else if(nums[i]<nums[i-1]) down=up+1;
        }
        return Math.max(up,down);
    }
}

//贪心
class Solution {
    public int wiggleMaxLength(int[] nums) {
        if(nums.length==0) return 0;
        int pre=0,cur=0,res=1;
        for(int i=1;i<nums.length;i++){
            cur=nums[i]-nums[i-1];
            if(cur>0&&pre<=0||pre>=0&&cur<0){
                res++;
                pre=cur;
            }
        }
        return res;
    }
}



1.1.3 最大子串和系列
//贪心
53. 最大子序和  连续子数组
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums.length==0) return 0;
        int[] dp=new int[nums.length+1];
        int res=nums[0];
        for(int i=1;i<dp.length;i++){
            dp[i]=dp[i-1]>0?dp[i-1]+nums[i-1]:nums[i-1];
            res=Math.max(res,dp[i]);
        }
        return res;
    }
}

class Solution {
    public int maxSubArray(int[] nums) {
        if(nums==null||nums.length==0) return 0;
        int res=nums[0],sum=nums[0];
        for(int i=1;i<nums.length;i++){
            sum=sum>0?nums[i]+sum:nums[i];
            res=Math.max(res,sum);
        }
        return res;
    }
}

class Solution {
    public int maxSubArray(int[] nums) {
        return dnc(nums,0,nums.length-1);
    }
    public int dnc(int[] nums,int l,int r){
        if(l>=r) return nums[l];
        int mid=l+((r-l)>>>1);
        int left=dnc(nums,l,mid);
        int right=dnc(nums,mid+1,r);

        int lsum=0,lmax=nums[mid];;
        for(int i=mid;i>=l;i--){
            lsum+=nums[i];
            lmax=Math.max(lmax,lsum);
        }
        int rsum=0,rmax=nums[mid+1];
        for(int i=mid+1;i<=r;i++){
            rsum+=nums[i];
            rmax=Math.max(rmax,rsum);
        }
        return Math.max(lmax+rmax,Math.max(left,right));
    }
}

152. 乘积最大子数组
//单独状态定义f[i]对导致f[i]无法从子状态推出，不符合最优子结构
class Solution {
    public int maxProduct(int[] nums) {
        int[] maxdp=new int[nums.length];
        int[] mindp=new int[nums.length];
        maxdp[0]=mindp[0]=nums[0];

        int res=nums[0];
        for(int i=1;i<nums.length;i++){
            if(nums[i]>0){
               maxdp[i]=Math.max(nums[i],maxdp[i-1]*nums[i]);
               mindp[i]=Math.min(nums[i],mindp[i-1]*nums[i]);
            }else{
               maxdp[i]=Math.max(nums[i],mindp[i-1]*nums[i]);
               mindp[i]=Math.min(nums[i],maxdp[i-1]*nums[i]);
            }
            res=Math.max(res,maxdp[i]);
        }
        return res;
    }
}

918. 环形子数组的最大和
class Solution {
    public int maxSubarraySumCircular(int[] A) {
        if(A==null||A.length==0) return 0;
        int max=A[0],min=0,cur=A[0],sum=A[0];
        for(int i=1;i<A.length;i++){
            sum+=A[i];
            cur=cur>0?A[i]+cur:A[i];
            max=Math.max(max,cur);
        }
        cur=0;
        for(int i=1;i<A.length-1;i++){
            cur=cur<=0?A[i]+cur:A[i];
            min=Math.min(min,cur);
        }
        return Math.max(max,sum-min);
    }
}

1191. K 次串联后最大子数组之和
class Solution {
    public int kConcatenationMaxSum(int[] arr, int k) {
        int mod=(int)(1e9+7),n=arr.length;
        long sum,max,prefix=arr[0],suffix=arr[n-1],maxprefix=prefix,maxsuffix=suffix;
        sum=max=arr[0]>0?arr[0]:0;
        for(int i=1;i<n;i++){
            prefix+=arr[i];
            suffix+=arr[n-i-1];
            if(maxprefix<prefix) maxprefix=prefix;
            if(maxsuffix<suffix) maxsuffix=suffix;

            sum=Math.max(sum+arr[i],arr[i]);
            max=Math.max(max,sum);
        }

        if(k==1) return (int)max%mod;
        long res=prefix>0?(maxprefix+maxsuffix+(k-2)*prefix)%mod:(maxprefix+maxsuffix)%mod;
        return (int)(Math.max(max,res));
    }
}

MaxDoubleSliceSum
class Solution {
    public int solution(int[] A) {
        int[] prefix=new int[A.length];
        int[] suffix=new int[A.length];
        int max=0;
        for(int i=1;i<A.length-1;i++){//[X+1,Y−1]
            max=Math.max(0,A[i]+max);
            prefix[i]=max;
        }
        max=0;
        for(int i=A.length-2;i>0;i--){//[Y−1,Z-1]
            max=Math.max(0,A[i]+max);
            suffix[i]=max;
        }
        int res=0;
        for(int i=1;i<A.length-1;i++){
            res=Math.max(res,prefix[i-1]+suffix[i+1]);
        }
        return res;
    }
}


面试题 17.24. 最大子矩阵
//ij判断行上下界,dp计算每一列总和
class Solution {
    public int[] getMaxMatrix(int[][] matrix) {
        int[] res=new int[4];
        int max=matrix[0][0];

        for(int i=0;i<matrix.length;i++){
            int[] dp=new int[matrix[0].length];
            for(int j=i;j<matrix.length;j++){
                int idx=0,curmax=0;
                for(int k=0;k<matrix[0].length;k++){
                    dp[k]+=matrix[j][k];
                    if(curmax>0) curmax+=dp[k];
                    else{
                        idx=k;
                        curmax=dp[k];
                    }
                    if(curmax>max){
                        max=curmax;
                        res[0]=i;
                        res[1]=idx;
                        res[2]=j;
                        res[3]=k;
                    }
                }
            }
        }
        return res;
    }
}

363. 矩形区域不超过 K 的最大数值和
class Solution {
    public int maxSumSubmatrix(int[][] matrix, int K) {
        int max=Integer.MIN_VALUE;
        for(int i=0;i<matrix[0].length;i++){
            int[] dp=new int[matrix.length];
            for(int j=i;j<matrix[0].length;j++){
                for(int k=0;k<matrix.length;k++) dp[k]+=matrix[k][j];

                int curmax=dp[0],sum=dp[0];
                for(int x=1;x<dp.length;x++){
                    sum=sum>0?sum+dp[x]:dp[x];
                    curmax=Math.max(curmax,sum);
                }
                if(curmax>K){
                    curmax=Integer.MIN_VALUE;
                    for(int x=0;x<dp.length;x++){
                        sum=0;
                        for(int y=x;y<dp.length;y++){
                            sum+=dp[y];
                            if(curmax<sum&&sum<=K) curmax=sum;
                        }
                    }
                }
                max=Math.max(max,curmax);
            }
        }
        return max;
    }
}

class Solution {
    public int maxSumSubmatrix(int[][] matrix, int K) {
        int max=Integer.MIN_VALUE;
        for(int i=0;i<matrix[0].length;i++){
            int[] dp=new int[matrix.length];
            for(int j=i;j<matrix[0].length;j++){
                for(int k=0;k<matrix.length;k++) dp[k]+=matrix[k][j];

                int curmax=Integer.MIN_VALUE,sum=0;
                TreeSet<Integer> set=new TreeSet<>();
                set.add(0);
                for(int num:dp){
                    sum+=num;
                    if(set.ceiling(sum-K)!=null){
                        curmax=sum-set.ceiling(sum-K);
                        max=Math.max(max,curmax);
                    }
                    set.add(sum);
                }
            }
        }
        return max;
    }
}

1186. 删除一次得到子数组最大和
class Solution {
    public int maximumSum(int[] arr) {
        int n=arr.length,res;
        int k=1;
        int[][] dp=new int[n][k+1];
        res=dp[0][0]=arr[0];
        for(int i=1;i<n;i++){
            dp[i][0]=Math.max(dp[i-1][0]+arr[i],arr[i]);
            res=Math.max(res,dp[i][0]);
        }
        for(int i=1;i<n;i++){
            for(int j=1;j<=k;j++){
                dp[i][j]=Math.max(dp[i-1][j]+arr[i],dp[i-1][j-1]);//要么选择当前数，要么删除当前数
                res=Math.max(res,dp[i][j]);
            }
        }
        return res;
    }
}


1.1.4 依然是单串,但是需要两个位置的情况: dp[i][j] 以 j, i 结尾
873. 最长的斐波那契子序列的长度
//无重复数字, dp[i][j]表示以A[j],A[i]双结尾的最大长度
class Solution {
    public int lenLongestFibSubseq(int[] A) {
        int n=A.length;
        Map<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<n;i++) map.put(A[i],i);

        int res=0;
        int[][] dp=new int[n][n-1];
        for(int i=0;i<n;i++){
            for(int j=i-1;j>=0;j--){
                int target=A[i]-A[j];
                if(map.containsKey(target)&&map.get(target)<j){
                    dp[i][j]=dp[j][map.get(target)]+1;
                    res=Math.max(res,dp[i][j]);
                }else dp[i][j]=2;
            }
        }
        return res==2?0:res;
    }
}

1027. 最长等差数列
//可能会有重复数字
class Solution {
    public int longestArithSeqLength(int[] A) {
        int n=A.length;
        Map<Integer,Integer> map=new HashMap<>();

        int[][] dp=new int[n][n-1];
        int res=0;
        for(int j=0;j<n-1;j++){
            for(int i=j+1;i<n;i++){
                int target=2*A[j]-A[i];
                if(map.containsKey(target)) dp[i][j]=dp[j][map.get(target)]+1;
                else dp[i][j]=2;
                res=Math.max(res,dp[i][j]);
            }
            map.put(A[j],j);
        }
        return res;
    }
}


1.1.5 其它单串且状态为 dp[i] 问题
413. 等差数列划分
//连续三位以i结尾有几个
class Solution {
    public int numberOfArithmeticSlices(int[] A) {
        if(A.length<3) return 0;
        int[] dp=new int[A.length];
        int res=0;
        for(int i=2;i<A.length;i++){
            if(A[i]-A[i-1]==A[i-1]-A[i-2]){
                dp[i]=dp[i-1]+1;
                res+=dp[i];
            }
        }
        return res;
    }
}

剑指 Offer 46. 把数字翻译成字符串
class Solution {
    public int translateNum(int num) {
        if(num<10) return 1;
        String s=String.valueOf(num);
        int n=s.length();
        int[] dp=new int[n+1];
        dp[0]=dp[1]=1;
        for(int i=2;i<=n;i++){
            int cur=s.charAt(i-1)-'0';
            int pre=s.charAt(i-2)-'0';
            if(pre==0||pre*10+cur>25) dp[i]=dp[i-1];
            else dp[i]=dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
}

91. 解码方法
class Solution {
    public int numDecodings(String s) {
        int n=s.length();
        if(n==0||s.charAt(0)=='0') return 0;
        if(n==1) return 1;
        int[] dp=new int[n+1];
        dp[0]=dp[1]=1;
        for(int i=2;i<=n;i++){
            int cur=s.charAt(i-1)-'0';
            int pre=s.charAt(i-2)-'0';
            if(cur+pre==0||cur==0&&pre>2) return 0;//len>2时, 0没有编码, 00和130为0
            else if(cur==0) dp[i]=dp[i-2];//只能和前一个字符组合变为一个
            else if(pre==0||pre*10+cur>26) dp[i]=dp[i-1];//只能和前一个拆开
            else dp[i]=dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
}

55. 跳跃游戏
//贪心
class Solution {
    public boolean canJump(int[] nums) {
        if(nums.length==0) return true;
        int right=0;
        for(int i=0;i<nums.length;i++){
            if(i>right) return false;
            right=Math.max(right,i+nums[i]);
        }
        return true;
    }
}

class Solution {
    public boolean canJump(int[] nums) {
        if(nums.length==0) return true;
        boolean[] dp=new boolean[nums.length];
        dp[0]=true;
        for(int i=1;i<nums.length;i++){
            for(int j=0;j<i;j++){
                if(dp[j]&&nums[j]+j>=i) dp[i]=true;
            }
        }
        return dp[nums.length-1];
    }
}

45. 跳跃游戏 II
//贪心
class Solution {
    public int jump(int[] nums) {
        if(nums.length==0) return 0;
        int right=0,cnt=0,end=0;
        for(int i=0;i<nums.length-1;i++){
            right=Math.max(right,nums[i]+i);
            if(i==end){
                cnt++;
                end=right;
            }
        }
        return cnt;
    }
}

class Solution {
    public int jump(int[] nums) {
        if(nums.length==0) return 0;
        int[] dp=new int[nums.length];
        dp[0]=0;
        for(int i=1;i<nums.length;i++){
            int right=0;
            while(right<nums.length&&nums[right]+right<i) right++;
            dp[i]=dp[right]+1;
        }
        return dp[nums.length-1];
    }
}

//滑动窗口
1696. 跳跃游戏 VI  dp+滑动窗口



1.2 双串问题, 状态为 dp[i][j], i 是第一串的时间或位置, j 是第二串的时间或位置

1.2.1 最经典双串 LCS 系列：
1143. 最长公共子序列LCS
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int n=text1.length(),m=text2.length();
        int[][] dp=new int[n+1][m+1];
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(text1.charAt(i-1)==text2.charAt(j-1)) dp[i][j]=dp[i-1][j-1]+1;
                else dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);
            }
        }
        return dp[n][m];
    }
}

//数组数字都不同: LCS->LIS
1713. 得到子序列的最少操作次数
//O(nlogn)
class Solution {
    public int minOperations(int[] target, int[] arr) {
        int n=target.length,m=arr.length;
        Map<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<n;i++) map.put(target[i],i);
        List<Integer> copy=new ArrayList<>();
        for(int i=0;i<m;i++) if(map.containsKey(arr[i])) copy.add(map.get(arr[i]));
        return n-lengthOfLIS(copy);
    }
    public int lengthOfLIS(List<Integer> nums) {
        int n=nums.size();
        if(n<=1) return n;

        int[] copy=new int[n];
        copy[0]=nums.get(0);
        int idx=0;
        for(int i=1;i<n;i++){
            if(nums.get(i)>copy[idx]) copy[++idx]=nums.get(i);
            else copy[insert_search(copy,nums.get(i),idx)]=nums.get(i);
        }
        return idx+1;
    }
    public int insert_search(int[] copy,int target,int end){
        int l=0,r=end;
        while(l<r){
            int m=l+((r-l)>>>1);
            if(copy[m]<target) l=m+1;
            else r=m;
        }
        return l;
    }
}

1092. 最短公共超序列
class Solution {
    public String shortestCommonSupersequence(String str1, String str2) {
        int n=str1.length(),m=str2.length();
        String[][] dp=new String[n+1][m+1];
        for(String[] d:dp) Arrays.fill(d,"");
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(str1.charAt(i-1)==str2.charAt(j-1)) dp[i][j]=dp[i-1][j-1]+str1.charAt(i-1);
                else dp[i][j]=dp[i-1][j].length()>dp[i][j-1].length()?dp[i-1][j]:dp[i][j-1];
            }
        }
        String lcs=dp[n][m],res="";
        int i=0,j=0;
        for(char c:lcs.toCharArray()){
            while(i<n&&c!=str1.charAt(i)) res+=str1.charAt(i++);
            while(j<m&&c!=str2.charAt(j)) res+=str2.charAt(j++);
            res+=c;
            i++;j++;
        }
        return res+str1.substring(i)+str2.substring(j);
    }
}

class Solution {
    public String shortestCommonSupersequence(String str1, String str2) {
        int n=str1.length(),m=str2.length();
        int[][] dp=new int[n+1][m+1];
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(str1.charAt(i-1)==str2.charAt(j-1)) dp[i][j]=dp[i-1][j-1]+1;
                else dp[i][j]=dp[i-1][j]>dp[i][j-1]?dp[i-1][j]:dp[i][j-1];
            }
        }
        StringBuilder res=new StringBuilder();
        for(int i=n,j=m,lcs=dp[n][m];i>0||j>0;){
            if(i>0&&j>0&&str1.charAt(i-1)==str2.charAt(j-1)){
                res.append(str1.charAt(i-1));
                lcs--;
                i--;
                j--;
            }else{
                if(j>0&&dp[i][j-1]==lcs) res.append(str2.charAt(--j));
                else res.append(str1.charAt(--i));
            }
        }
        return res.reverse().toString();
    }
}

718. 最长重复子数组


1.2.2 字符串匹配系列
72. 编辑距离
class Solution {
    public int minDistance(String word1, String word2) {
        int[][] dp=new int[word1.length()+1][word2.length()+1];
        for(int i=0;i<=word1.length();i++){
            for(int j=0;j<=word2.length();j++){
                if(i==0) dp[i][j]=j;
                else if(j==0) dp[i][j]=i;
                else{
                    if(word1.charAt(i-1)==word2.charAt(j-1)) dp[i][j]=dp[i-1][j-1];
                    else dp[i][j]=Math.min(dp[i-1][j-1],Math.min(dp[i-1][j],dp[i][j-1]))+1;
                }
            }
        }
        return dp[word1.length()][word2.length()];
    }
}

面试题 01.05. 一次编辑
class Solution {
    public boolean oneEditAway(String f, String s) {
        if(f.equals(s)) return true;
        int s1=f.length(),s2=s.length();
        if(s1-s2>1||s2-s1>1) return false;
        int[][] dp=new int[s1+1][s2+1];
        for(int i=1;i<=s1;i++) dp[i][0]=i;
        for(int i=1;i<=s2;i++) dp[0][i]=i;
        for(int i=1;i<=s1;i++){
            for(int j=1;j<=s2;j++){
                if(f.charAt(i-1)==s.charAt(j-1)) dp[i][j]=dp[i-1][j-1];
                else dp[i][j]=Math.min(dp[i-1][j-1],Math.min(dp[i-1][j],dp[i][j-1]))+1;
            }
        }
        return dp[s1][s2]<=1;
    }
}

class Solution {
    public boolean oneEditAway(String f, String s) {
        if(f.equals(s)) return true;
        int s1=f.length(),s2=s.length();
        if(s1-s2>1||s2-s1>1) return false;
        int l=0,r1=s1-1,r2=s2-1;
        while(l<=r1&&l<=r2&&f.charAt(l)==s.charAt(l)) l++;
        while(r1>=0&&r2>=0&&f.charAt(r1)==s.charAt(r2)){r1--;r2--;}
        return r1-l<1&&r2-l<1;
    }
}

583. 两个字符串的删除操作
class Solution {
    public int minDistance(String word1, String word2) {
        int n=word1.length(),m=word2.length();
        int[][] dp=new int[n+1][m+1];
        for(int j=1;j<=m;j++) dp[0][j]=j;
        for(int i=1;i<=n;i++) dp[i][0]=i;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(word1.charAt(i-1)==word2.charAt(j-1)) dp[i][j]=dp[i-1][j-1];
                else dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+1;
            }
        }
        return dp[n][m];
    }
}

class Solution {
    public int minDistance(String word1, String word2) {
        int n=word1.length(),m=word2.length();
        int[][] dp=new int[n+1][m+1];
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(word1.charAt(i-1)==word2.charAt(j-1)) dp[i][j]=dp[i-1][j-1]+1;
                else dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);
            }
        }
        return n+m-2*dp[n][m];
    }
}

712. 两个字符串的最小ASCII删除和
class Solution {
    public int minimumDeleteSum(String word1, String word2) {
        int n=word1.length(),m=word2.length();
        int[][] dp=new int[n+1][m+1];
        for(int j=1;j<=m;j++) dp[0][j]=dp[0][j-1]+word2.charAt(j-1);
        for(int i=1;i<=n;i++) dp[i][0]=dp[i-1][0]+word1.charAt(i-1);
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(word1.charAt(i-1)==word2.charAt(j-1)) dp[i][j]=dp[i-1][j-1];
                else dp[i][j]=Math.min(dp[i-1][j]+word1.charAt(i-1),dp[i][j-1]+word2.charAt(j-1));
            }
        }
        return dp[n][m];
    }
}

650. 只有两个键的键盘
class Solution {
    public int minSteps(int n) {
        if(n==1) return 0;
        int[] dp=new int[n+1];
        for(int i=2;i<=n;i++){
            dp[i]=i;
            for(int j=2;j*j<=i;j++) {
                if(i%j==0){
                    dp[i]=dp[i/j]+dp[j];
                    break;
                }
            }
        }
        return dp[n];
    }
}

class Solution {
    public int minSteps(int n) {
        int res=0;
        for(int j=2;n>1;j++){
            while(n%j==0){
                res+=j;
                n/=j;
            }
        }
        return res;
    }
}

//https://leetcode-cn.com/problems/regular-expression-matching/solution/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8/
10. 正则表达式匹配
class Solution {
    public boolean isMatch(String s, String p) {
        boolean[][] dp=new boolean[s.length()+1][p.length()+1];
        dp[0][0]=true;
        for(int i=1;i<=p.length();i++){
            if(p.charAt(i-1)=='*') dp[0][i]=dp[0][i-2];
        }
        for(int i=1;i<=s.length();i++){
            for(int j=1;j<=p.length();j++){
                if(s.charAt(i-1)==p.charAt(j-1)||p.charAt(j-1)=='.') dp[i][j]=dp[i-1][j-1];
                else if(p.charAt(j-1)=='*'){
                    if(s.charAt(i-1)!=p.charAt(j-2)&&p.charAt(j-2)!='.') dp[i][j]=dp[i][j-2];
                    else dp[i][j]=dp[i][j-1]||dp[i-1][j]||dp[i][j-2];//*使得p[j-2]出现0次，1次，2次以上
                }
            }
        }
        return dp[s.length()][p.length()];
    }
}

44. 通配符匹配
class Solution {
    public boolean isMatch(String s, String p) {
        boolean[][] dp=new boolean[s.length()+1][p.length()+1];
        dp[0][0]=true;
        for(int i=1;i<=p.length();i++){
            if(p.charAt(i-1)=='*') dp[0][i]=dp[0][i-1];
        }
        for(int i=1;i<=s.length();i++){
            for(int j=1;j<=p.length();j++){
                if(s.charAt(i-1)==p.charAt(j-1)||p.charAt(j-1)=='?') dp[i][j]=dp[i-1][j-1];
                else if(p.charAt(j-1)=='*') dp[i][j]=dp[i][j-1]||dp[i-1][j];//*使得p[j-2]出现0次，1次以上
            }
        }
        return dp[s.length()][p.length()];
    }
}


1.3 单串问题, 状态为 dp[i][k]  i 是位置、时间、高度等；k 是长度、个数、次数、颜色等。k 这一维上可能有二分，贪心等各种优化方法




1.4 单串问题, 状态为 dp[i][k1][k2]

1.4.1 股票系列: dp[i][k][state] i 是时间，k 是次数，state 是状态机(在某一个位置或者时刻可以选择多种状态)
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])

121. 买卖股票的最佳时机 一次交易
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length<2) return 0;
        int min=Integer.MAX_VALUE,max=0;
        for(int i:prices){
            if(i<min) min=i;
            else if(i-min>max) max=i-min;
        }
        return max;
    }
}

class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length<2) return 0;
        int n=prices.length;
        int[][] dp=new int[n+1][2];//dp[0]持有股票最大值,dp[1]抛售股票最大值
        dp[1][0]=0;dp[1][1]=-prices[0];
        for(int i=2;i<=n;i++){
            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i-1]);//没有是前一天没有, 或者是前一天持有加今天卖了
            dp[i][1]=Math.max(dp[i-1][1],-prices[i-1]);//有是前一天有, 或者是今天买的, 因为只能交易一次, 利润为负
        }
        return dp[n][0];
    }
}

122. 买卖股票的最佳时机 II 无限次交易
class Solution {
    public int maxProfit(int[] prices) {
        int res=0;
        for(int i=1;i<prices.length;i++){
            if(prices[i]>prices[i-1]) res+=prices[i]-prices[i-1];
        }
        return res;
    }
}

class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length<2) return 0;
        int n=prices.length;
        int[][] dp=new int[n+1][2];
        dp[1][0]=0;dp[1][1]=-prices[0];
        for(int i=2;i<=n;i++){
            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i-1]);
            dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i-1]);
        }
        return dp[n][0];
    }
}

123. 买卖股票的最佳时机 III 两笔交易
188. 买卖股票的最佳时机 IV k笔交易
class Solution {
    public int maxProfit(int k, int[] prices) {
        if(prices.length<2) return 0;
        int n=prices.length;
        int[][][] dp=new int[n+1][k+1][2];
        for(int j=0;j<=k;j++){
            dp[1][j][0]=0;
            dp[1][j][1]=-prices[0];
        }
        for(int i=2;i<=n;i++){
            for(int j=1;j<=k;j++){
                dp[i][j][0]=Math.max(dp[i-1][j][0],dp[i-1][j][1]+prices[i-1]);
                dp[i][j][1]=Math.max(dp[i-1][j][1],dp[i-1][j-1][0]-prices[i-1]);
            }
        }
        return dp[n][k][0];
    }
}

class Solution {
    public int maxProfit(int k, int[] prices) {
        if(prices.length<2) return 0;
        int n=prices.length;
        if(k>=n/2){//太大变为无限次
            int res=0;
            for(int i=1;i<prices.length;i++){
                if(prices[i]>prices[i-1]) res+=prices[i]-prices[i-1];
            }
            return res;
        }

        int[][] dp=new int[k+1][2];
        for(int j=0;j<=k;j++){
            dp[j][0]=0;
            dp[j][1]=-prices[0];
        }
        for(int i=0;i<n;i++){
            for(int j=1;j<=k;j++){
                dp[j][0]=Math.max(dp[j][0],dp[j][1]+prices[i]);
                dp[j][1]=Math.max(dp[j][1],dp[j-1][0]-prices[i]);
            }
        }
        return dp[k][0];
    }
}

309. 最佳买卖股票时机含冷冻期 cd为1天
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length<2) return 0;
        int n=prices.length;
        int[][] dp=new int[n+1][2];
        dp[1][0]=0;dp[1][1]=-prices[0];
        for(int i=2;i<=n;i++){
            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i-1]);
            dp[i][1]=Math.max(dp[i-1][1],dp[i-2][0]-prices[i-1]);
        }
        return dp[n][0];
    }
}

714. 买卖股票的最佳时机含手续费 每笔交易手续费
class Solution {
    public int maxProfit(int[] prices, int fee) {
        if(prices.length<2) return 0;
        int n=prices.length;
        int[] dp=new int[2];
        dp[0]=0;dp[1]=-prices[0];
        for(int i=0;i<n;i++){
            dp[0]=Math.max(dp[0],dp[1]+prices[i]-fee);
            dp[1]=Math.max(dp[1],dp[0]-prices[i]);
        }
        return dp[0];
    }
}





1.6 矩阵问题 dp[i][j] (i, j) 共同表示位置

120. 三角形最小路径和
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n=triangle.size(),m=triangle.get(n-1).size();
        int[][] dp=new int[n+1][m+1];
        for(int i=n-1;i>=0;i--){
            for(int j=0;j<=i;j++){
                dp[i][j]=Math.min(dp[i+1][j+1],dp[i+1][j])+triangle.get(i).get(j);
            }
        }
        return dp[0][0];
    }
}

//只用到了下一行, 只要定义 1 行
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int n=triangle.size(),m=triangle.get(n-1).size();
        int[] dp=new int[m+1];
        for(int i=n-1;i>=0;i--){
            for(int j=0;j<=i;j++){
                dp[j]=Math.min(dp[j+1],dp[j])+triangle.get(i).get(j);
            }
        }
        return dp[0];
    }
}

64. 最小路径和
class Solution {
    public int minPathSum(int[][] grid) {
        if(grid.length==0) return 0;
        int n=grid.length,m=grid[0].length;

        int[][] dp=new int[n][m];
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(i==0&&j==0) dp[i][j]=grid[i][j];
                else if(i==0) dp[i][j]=dp[i][j-1]+grid[i][j];
                else if(j==0) dp[i][j]=dp[i-1][j]+grid[i][j];
                else dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j];
            }
        }
        return dp[n-1][m-1];
    }
}

174. 地下城游戏
//dp[i][j] 从i,j到达右下角所需的最少生命值
class Solution {
    public int calculateMinimumHP(int[][] grid) {
        if(grid.length==0||grid[0].length==0) return 0;
        int n=grid.length,m=grid[0].length;
        int[][] dp=new int[n][m];
        dp[n-1][m-1]=grid[n-1][m-1]>0?1:-grid[n-1][m-1]+1;
        for(int i=n-2;i>=0;i--){
            int cur=dp[i+1][m-1]-grid[i][m-1];
            dp[i][m-1]=cur>0?cur:1;
        }
        for(int j=m-2;j>=0;j--){
            int cur=dp[n-1][j+1]-grid[n-1][j];
            dp[n-1][j]=cur>0?cur:1;
        }
        for(int i=n-2;i>=0;i--){
            for(int j=m-2;j>=0;j--){
                int cur=Math.min(dp[i+1][j],dp[i][j+1])-grid[i][j];
                dp[i][j]=cur>0?cur:1;
            }
        }
        return dp[0][0];
    }
}

62. 不同路径
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp=new int[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(i==0) dp[i][j]=1;
                else if(j==0) dp[i][j]=1;
                else dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}

63. 不同路径 II
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m=obstacleGrid.length,n=obstacleGrid[0].length;
        int[][] dp=new int[m][n];
        for(int i=0;i<m&&obstacleGrid[i][0]==0;i++){
            dp[i][0]=1;
        }
        for(int j=0;j<n&&obstacleGrid[0][j]==0;j++){
            dp[0][j]=1;
        }
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                if(obstacleGrid[i][j]==0) dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}

542. 01 矩阵
class Solution {
    public int[][] updateMatrix(int[][] matrix) {
        int n=matrix.length,m=matrix[0].length;
        int[][] dp=new int[n][m];
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(matrix[i][j]==1) dp[i][j]=Integer.MAX_VALUE/2;
            }
        }

        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(i>0) dp[i][j]=Math.min(dp[i][j],dp[i-1][j]+1);
                if(j>0) dp[i][j]=Math.min(dp[i][j],dp[i][j-1]+1);
            }
        }
        for(int i=n-1;i>=0;i--){
            for(int j=m-1;j>=0;j--){
                if(i<n-1) dp[i][j]=Math.min(dp[i][j],dp[i+1][j]+1);
                if(j<m-1) dp[i][j]=Math.min(dp[i][j],dp[i][j+1]+1);
            }
        }
        return dp;
    }
}

//单调栈
221. 最大正方形
class Solution {
    public int maximalSquare(char[][] matrix) {
        if(matrix.length==0||matrix[0].length==0) return 0;
        int n=matrix.length,m=matrix[0].length,max=0;
        int[][] dp=new int[n+1][m+1];
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(matrix[i-1][j-1]=='1') dp[i][j]=Math.min(dp[i-1][j-1],Math.min(dp[i][j-1],dp[i-1][j]))+1;
                max=Math.max(max,dp[i][j]);
            }
        }
        return max*max;
    }
}

//单调栈
85. 最大矩形
class Solution {
    public int maximalRectangle(char[][] matrix) {
        if(matrix.length==0||matrix[0].length==0) return 0;
        int res=0;
        int[][] dp=new int[matrix.length+1][matrix[0].length+1];
        for(int i=1;i<=matrix.length;i++){
            for(int j=1;j<=matrix[0].length;j++){
                if(matrix[i-1][j-1]=='1'){
                    dp[i][j]=dp[i][j-1]+1;
                    int len=dp[i][j];
                    for(int k=i;k>0&&matrix[k-1][j-1]=='1';k--){
                        len=Math.min(len,dp[k][j]);
                        res=Math.max(res,len*(i-k+1));
                    }
                }
            }
        }
        return res;
    }
}


1.8 无串线性 dp



2、背包 DP
01背包:   dp[i][j]=max(dp[i-1][j], dp[i-1][j-v[i]]+w[i])
完全背包: dp[i][j]=max(dp[i-1][j], dp[i][j-v[i]]+w[i])

01背包
//v体积,w价值
//dp[i][j] 表示体积不超过j, 只能装i件物品, 能达到的最大价值
//O(nm) O(nm)
class Solution {
    public int backPack(int n,int m,int[] v,int[] w) {
        int[][] dp=new int[n+1][m+1];
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                dp[i][j]=dp[i-1][j];
                if(j>=v[i]) dp[i][j]=Math.max(dp[i][j],dp[i-1][j-v[i]]+w[i]);
            }
        }
        return dp[n][m];
    }
}

//优化
//dp[i]仅用到了dp[i-1]层, j与j-v[i]均小于j,
class Solution {
    public int backPack(int n,int m,int[] v,int[] w) {
        int[] dp=new int[m+1];
        for(int i=1;i<=n;i++){
            for(int j=m;j>=v[i];j--){
                dp[j]=Math.max(dp[j],dp[j-v[i]]+w[i]);
            }
        }
        return dp[m];
    }
}

完全背包
class Solution {
    public int backPack(int n,int m,int[] v,int[] w) {
        int[][] dp=new int[n+1][m+1];
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                dp[i][j]=dp[i-1][j];
                if(j>=v[i]) dp[i][j]=Math.max(dp[i][j],dp[i][j-v[i]]+w[i]);
            }
        }
        return dp[n][m];
    }
}

//优化
class Solution {
    public int backPack(int n,int m,int[] v,int[] w) {
        int[] dp=new int[m+1];
        for(int i=1;i<=n;i++){
            for(int j=v[i];j<=m;j++){
                dp[j]=Math.max(dp[j],dp[j-v[i]]+w[i]);
            }
        }
        return dp[m];
    }
}

多重背包 个数限制为s[i]
class Solution {
    public int backPack(int n,int m,int[] s,int[] v,int[] w) {
        int[][] dp=new int[n+1][m+1];
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                dp[i][j]=dp[i-1][j];
                for(int k=1;k<=s[i];k++){
                    if(j>=k*v[i]) dp[i][j]=Math.max(dp[i][j],dp[i-1][j-k*v[i]]+k*w[i]);
            }
        }
        return dp[n][m];
    }
}

//优化
class Solution {
    public int backPack(int n,int m,int[] s,int[] v,int[] w) {
        int[] dp=new int[m+1];
        for(int i=1;i<=n;i++){
            for(int j=m;j>=v[i];j--){
                for(int k=1;k<=s[i]&&j>=k*v[i];k++){
                    dp[j]=Math.max(dp[j],dp[j-k*v[i]]+k*w[i]);
            }
        }
        return dp[n][m];
    }
}

多重背包的二进制优化
多重背包单调队列优化

322. 零钱兑换 完全背包
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp=new int[amount+1];
        Arrays.fill(dp,amount+1);
        dp[0]=0;
        for(int i=0;i<coins.length;i++){
            for(int j=coins[i];j<=amount;j++){
                dp[j]=Math.min(dp[j],dp[j-coins[i]]+1);
            }
        }
        return dp[amount]>amount?-1:dp[amount];
    }
}

474. 一和零 二维费用背包
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp=new int[m+1][n+1];
        for(String s:strs){
            int[] cnt=count(s);
            for(int i=m;i>=cnt[0];i--){
                for(int j=n;j>=cnt[1];j--){
                    dp[i][j]=Math.max(dp[i][j],dp[i-cnt[0]][j-cnt[1]]+1);
                }
            }
        }
        return dp[m][n];
    }
    public int[] count(String s){
        int cnt0=0,cnt1=0;
        for(char c:s.toCharArray()){
            if(c=='1') cnt1++;
            else cnt0++;
        }
        return new int[]{cnt0,cnt1};
    }
}

416. 分割等和子集 01背包要求恰好取到背包容量
class Solution {
    public boolean canPartition(int[] nums) {
        int sum=Arrays.stream(nums).sum(),target=sum/2;
        if(sum%2==1) return false;
        int[] dp=new int[target+1];
        for(int i=0;i<nums.length;i++){
            for(int j=target;j>=nums[i];j--){
                dp[j]=Math.max(dp[j],dp[j-nums[i]]+nums[i]);
            }
        }
        return dp[target]==target;
    }
}

class Solution {
    public boolean canPartition(int[] nums) {
        int sum=Arrays.stream(nums).sum(),target=sum/2;
        if(sum%2==1) return false;
        boolean[] dp=new boolean[target+1];
        dp[0]=true;
        for(int i=0;i<nums.length;i++){
            for(int j=target;j>=nums[i];j--){
                if(j==nums[i]) dp[j]=true;
                else dp[j]=dp[j]||dp[j-nums[i]];
            }
        }
        return dp[target];
    }
}

//回溯
494. 目标和 01背包求方案数
/*可以转化为一个子集划分问题，子集划分问题又是一个典型的背包问题。
nums 划分成子集A和B, 分别代表 分配+的数 和 分配-的数
sum(A) - sum(B) = target
sum(A) + sum(A) = target + sum(B) + sum(A)
2 * sum(A) = target + sum(nums)
sum(A) = (target + sum(nums)) / 2
也就是把原问题转化成: nums 中存在几个子集 A, 使得 A 中元素的和为 (target + sum(nums))/2 ？*/
class Solution {
    int res=0;
    public int findTargetSumWays(int[] nums, int S) {
        if(nums.length==0) return 0;
        int sum=Arrays.stream(nums).sum(),target=(sum+S)/2;
        if(sum<S||(sum+S)%2==1) return 0;
        int[] dp=new int[target+1];
        dp[0]=1;
        for(int i=0;i<nums.length;i++){
            for(int j=target;j>=nums[i];j--){
                dp[j]=dp[j]+dp[j-nums[i]];
            }
        }
        return dp[target];
    }
}

518. 零钱兑换 II 完全背包求方案数
//回溯超时
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp=new int[amount+1];
        dp[0]=1;
        for(int i=0;i<coins.length;i++){
            for(int j=coins[i];j<=amount;j++){
                dp[j]=dp[j]+dp[j-coins[i]];
            }
        }
        return dp[amount];
    }
}

377. 组合总和 Ⅳ 完全背包求方案数  不同序列
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp=new int[target+1];
        dp[0]=1;
        for(int i=1;i<=target;i++){
            for(int j=0;j<nums.length;j++){
                if(nums[j]<=i) dp[i]=dp[i]+dp[i-nums[j]];
            }
        }
        return dp[target];
    }
}

279. 完全平方数
//用1,4,9这些数凑target,322. 零钱兑换
//完全平方数和为i的最小个数
class Solution {
    public int numSquares(int n) {
        if(n==0) return 0;
        int[] dp=new int[n+1];
        for(int i=1;i<=n;i++){
            dp[i]=i;
            for(int j=1;j*j<=i;j++){
                dp[i]=Math.min(dp[i],dp[i-j*j]+1);
            }
        }
        return dp[n];
    }
}

class Solution {
    public int numSquares(int n) {
        if(n==0) return 0;
        while(n%4==0) n/=4;
        if(n%8==7) return 4;

        int sqrt=(int)Math.sqrt(n);
        if(n==sqrt*sqrt) return 1;

        for(int i=1;i*i<=n;i++){
            int x=n-i*i;
            sqrt=(int)Math.sqrt(x);
            if(x==sqrt*sqrt) return 2;
        }
        return 3;
    }
}

343. 整数拆分/剑指 Offer 14- I. 剪绳子
class Solution {
    public int integerBreak(int n) {
        int[] dp=new int[n+1];
        Arrays.fill(dp,1);
        for(int i=1;i<=n;i++){
            for(int j=1;j<=i-j;j++){
                dp[i]=Math.max(dp[i],Math.max(j*(i-j),dp[i-j]*j));//拆为j i-j, 要么继续拆j-i
            }
        }
        return dp[n];
    }
}

class Solution {
    public int integerBreak(int n) {
        if(n<=2) return 1;
        if(n==3) return 2;
        else if(n%3==0) return (int)Math.pow(3,n/3);
        else if(n%3==1) return 4*(int)Math.pow(3,(n-4)/3);
        else return 2*(int)Math.pow(3,n/3);
    }
}

剑指 Offer 14- II. 剪绳子 II
//贪心, n>=5, 3(n-3) >= 2(n-2), 多剪3的绳子段
class Solution {
    public int cuttingRope(int n) {
        if(n<=2) return 1;
        if(n==3) return 2;
        int MOD=(int)1e9+7;
        long res=1;
        while(n>4){
            res=res*3%MOD;
            n-=3;
        }
        return (int)(res*n%MOD);
    }
}

1049. 最后一块石头的重量 II



3、区间 DP
减治型
5. 最长回文子串
//中心扩散
class Solution {
    public String longestPalindrome(String s) {
        if(s.length()<2) return s;
        int n=s.length();
        int len=1;
        String res=s.substring(0,1);
        for(int i=0;i<n-1;i++){
            String odd=getP(s,i,i);
            String even=getP(s,i,i+1);
            String max=odd.length()>even.length()?odd:even;
            if(max.length()>len){
                len=max.length();
                res=max;
            }
        }
        return res;
    }
    public String getP(String s,int l,int r) {
        for(int n=s.length();l>=0&&r<n&&s.charAt(l)==s.charAt(r);) {
            l--;
            r++;
        }
        return s.substring(l+1,r);
    }
}

//O(n^3) O(1)
class Solution {
    public String longestPalindrome(String s) {
        if(s.length()<2) return s;
        int n=s.length();
        char[] word=s.toCharArray();
        int l=0,len=1;
        for(int i=1;i<word.length;i++){
            for(int j=0;j<i;j++){
                if(valid(word,j,i)&&len<i-j+1){
                    len=i-j+1;
                    l=j;
                }
            }
        }
        return s.substring(l,l+len);
    }
    public boolean valid(char[] word,int l,int r) {
        for(;l<r;l++,r--) {
            if(word[l]!=word[r]) return false;
        }
        return true;
    }
}

//O(n^2) O(n^2)
class Solution {
    public String longestPalindrome(String s) {
        if(s.length()<2) return s;
        int n=s.length();
        int l=0,len=1;
        boolean[][] dp=new boolean[n][n];
        for(int i=1;i<n;i++){
            for(int j=0;j<i;j++){
                if(s.charAt(i)==s.charAt(j)&&(i-j+1<=3||dp[j+1][i-1])){
                    dp[j][i]=true;
                    if(len<i-j+1){
                        len=i-j+1;
                        l=j;
                    }
                }
            }
        }
        return s.substring(l,l+len);
    }
}


分治型
312. 戳气球
//dp[i][j]表示(i,j)能拿到的最多金币, k是[i,j]区间最后戳破的气球, 所以其左右并没有气球, 只有开区间(i,j)
//加上dp[i][k]和dp[k][j], k是最后一个被戳爆的，所以(i,j)k两边的东西必然是先各自被戳爆了的
class Solution {
    public int maxCoins(int[] nums) {
        int n=nums.length;
        int[] copy=new int[n+2];
        for(int i=0;i<n+2;i++){
            if(i==0||i==n+1) copy[i]=1;
            else copy[i]=nums[i-1];
        }
        int[][] dp=new int[n+2][n+2];
        for(int len=1;len<=n+2;len++){
            for(int i=0;i+len-1<=n+1;i++){
                int j=i+len-1;
                for(int k=i+1;k<j;k++){
                    dp[i][j]=Math.max(dp[i][j],dp[i][k]+copy[i]*copy[k]*copy[j]+dp[k][j]);
                }
            }
        }
        return dp[0][n+1];
    }
}


4、树形 DP
337. 打家劫舍 III
class Solution {
    Map<TreeNode,Integer> map=new HashMap<>();
    public int rob(TreeNode root) {
        if(root==null) return 0;
        if(map.containsKey(root)) return map.get(root);
        int do_it=root.val+(root.left==null?0:rob(root.left.left)+rob(root.left.right))+(root.right==null?0:rob(root.right.left)+rob(root.right.right));
        int not_do=rob(root.left)+rob(root.right);
        int res=Math.max(do_it,not_do);
        map.put(root,res);
        return res;
    }
}

class Solution {
    public int rob(TreeNode root) {
        int[] res=dp(root);
        return Math.max(res[0], res[1]);
    }
    public int[] dp(TreeNode root) {
        if(root==null) return new int[]{0, 0};
        int[] left=dp(root.left);//后序遍历
        int[] right=dp(root.right);
        int rob=root.val+left[0]+right[0];
        int not_rob=Math.max(left[0],left[1])+Math.max(right[0],right[1]);
        return new int[]{not_rob, rob};
    }
}

5、状态压缩 DP
526. 优美的排列
class Solution {
    int res=0;
    public int countArrangement(int N) {
        boolean[] visited=new boolean[N+1];
        backtrack(N,1,visited);
        return res;
    }
    public void backtrack(int N,int pos,boolean[] visited) {
        if(pos>N){
            res++;
            return;
        }
        for(int i=1;i<=N;i++){
            if(!visited[i]&&(pos%i==0||i%pos==0)){
                visited[i]=true;
                backtrack(N,pos+1,visited);
                visited[i]=false;
            }
        }
    }
}

class Solution {
    public int countArrangement(int N) {
        int[] dp=new int[1<<N];
        Arrays.fill(dp,-1);
        return dfs(N,1,0,dp);
    }
    public int dfs(int N,int pos,int state,int[] dp) {
        if(pos>N) return 1;
        if(dp[state]!=-1) return dp[state];
        int res=0;
        for(int i=1;i<=N;i++){
            int bit=1<<(i-1);
            if((state&bit)==0&&(pos%i==0||i%pos==0)){
                res+=dfs(N,pos+1,state|bit,dp);
            }
        }
        dp[state]=res;
        return res;
    }
}

464. 我能赢吗
class Solution {
    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {
        int sum=(1+maxChoosableInteger)*maxChoosableInteger/2;
        if(sum<desiredTotal) return false;
        int[] visited=new int[maxChoosableInteger+1];
        return dfs(visited,desiredTotal,new HashMap<String, Boolean>());
    }
    public boolean dfs(int[] visited,int desiredTotal,HashMap<String, Boolean> map){
        String cur=Arrays.toString(visited);
        if(map.containsKey(cur)) return map.get(cur);

        for(int i=1;i<visited.length;i++){
            if(visited[i]==1) continue;
            visited[i]=1;
            if(i>=desiredTotal||!dfs(visited,desiredTotal-i,map)){
                map.put(cur,true);
                visited[i]=0;
                return true;
            }
            visited[i]=0;
        }
        map.put(cur,false);
        return false;
    }
}

//https://leetcode-cn.com/problems/can-i-win/solution/zhuang-tai-ya-suo-de-dong-tai-gui-hua-hui-su-bo-yi/
//用二进制的第i位的0或1来表示i这个数字的选取与否
//对于每一个状态来说其desiredTotal都是确定的，因此无需记录desiredTotal。
class Solution {
    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {
        int sum=(1+maxChoosableInteger)*maxChoosableInteger/2;
        if(sum<desiredTotal) return false;
        boolean[] dp=new boolean[1<<maxChoosableInteger];
        return dfs(maxChoosableInteger,desiredTotal,0,dp);
    }
    public boolean dfs(int maxChoosableInteger,int desiredTotal,int state,boolean[] dp){
        if(dp[state]) return dp[state];

        for(int i=1;i<=maxChoosableInteger;i++){
            int bit=1<<(i-1);
            if((bit&state)!=0) continue;
            if(i>=desiredTotal||!dfs(maxChoosableInteger,desiredTotal-i,bit|state,dp)){
                dp[state]=true;
                return true;
            }
        }
        dp[state]=false;
        return false;
    }
}

6、数位 DP

7、计数问题
计数型DP都可以以组合数学的方法写出组合数，然后dp求组合数

8、概率型 DP
剑指 Offer 60. n个骰子的点数
//dp[n][s] n个朝上的面的点数之和为s的事件出现的次数
//dp[2][4]=d[1][1]+dp[1][2]+dp[1][3]
class Solution {
    public double[] dicesProbability(int n) {
        int[][] dp=new int[n+1][6*n+1];
        for(int i=1;i<=6;i++) dp[1][i]=1;
        for(int i=2;i<=n;i++){
            for(int j=i;j<=6*i;j++){
                for(int k=1;k<=6;k++){
                    if(j-k<=0) break;
                    dp[i][j]+=dp[i-1][j-k];
                }
            }
        }
        double denom=(double)Math.pow(6,n);
        double[] res=new double[n*6-(n-1)];
        for(int i=n;i<=6*n;i++) res[i-n]=dp[n][i]/denom;
        return res;
    }
}

10、博弈型 DP


翻转游戏


石子游戏
486. 预测赢家
class Solution {
    public boolean PredictTheWinner(int[] nums) {
        int[][] dp=new int[nums.length][nums.length];
        for(int i=0;i<nums.length;i++) dp[i][i]=nums[i];
        for(int i=nums.length-2;i>=0;i--){
            for(int j=i+1;j<nums.length;j++){
                dp[i][j]=Math.max(nums[i]-dp[i+1][j],nums[j]-dp[i][j-1]);
            }
        }
        return dp[0][nums.length-1]>=0;
    }
}

877. 石子游戏
//Alex必赢, 因为是偶数堆, Alex是先手, 每次都拿大的一堆, 两个人最终拿到的石子堆总数是一样的
class Solution {
    public boolean stoneGame(int[] piles) {
        int[][] dp=new int[piles.length][piles.length];
        for(int i=0;i<piles.length;i++) dp[i][i]=piles[i];
        for(int i=piles.length-2;i>=0;i--){
            for(int j=i+1;j<piles.length;j++){
                dp[i][j]=Math.max(piles[i]-dp[i+1][j],piles[j]-dp[i][j-1]);
            }
        }
        return dp[0][piles.length-1]>0;
    }
}

1690. 石子游戏 VII
//零和博弈dp
//dp[i][j]=[i,j]石头的得分最大差值
class Solution {
    public int stoneGameVII(int[] stones) {
        int[] prefix=new int[stones.length+1];
        for(int i=1;i<=stones.length;i++) prefix[i]=prefix[i-1]+stones[i-1];
        int[][] dp=new int[stones.length][stones.length];
        for(int i=stones.length-2;i>=0;i--){
            for(int j=i+1;j<stones.length;j++){
                dp[i][j]=Math.max(get(prefix,i+1,j)-dp[i+1][j],get(prefix,i,j-1)-dp[i][j-1]);
            }
        }
        return dp[0][stones.length-1];
    }
    public int get(int[] pre,int i,int j){
        return pre[j+1]-pre[i];
    }
}

1140. 石子游戏 II
//dp[i][j]表示[i,len]取j个石头时最大分数
//假设先手选了前i堆,则先手得到的最大数量=max(总量-对手最多拿到的数量)
class Solution {
    public int stoneGameII(int[] piles) {
        int n=piles.length,sum=0;
        int[][] dp=new int[n][n+1];
        int[] suffix=new int[n+1];
        for(int i=n-1;i>=0;i--) suffix[i]=suffix[i+1]+piles[i];

        for(int i=n-1;i>=0;i--){
            for(int M=1;M<=n;M++){
                if(i+2*M>=n) dp[i][M]=suffix[i];
                else{
                    for(int x=1;x<=2*M;x++) dp[i][M]=Math.max(dp[i][M],suffix[i]-dp[i+x][Math.max(x,M)]);
                }
            }
        }
        return dp[0][1];
    }
}


1686. 石子游戏 VI
class Solution {
    public int stoneGameVI(int[] aliceValues, int[] bobValues) {
        int[][] copy=new int[aliceValues.length][2];
        for(int i=0;i<aliceValues.length;i++){
            copy[i][0]=aliceValues[i]+bobValues[i];
            copy[i][1]=i;
        }

        Arrays.sort(copy,(a,b)->(b[0]-a[0]));
        int sum1=0,sum2=0;
        for(int i=0;i<copy.length;i++){
            if(i%2==0) sum1+=aliceValues[copy[i][1]];
            else sum2+=bobValues[copy[i][1]];
        }
        if(sum1==sum2) return 0;
        else if(sum1>sum2) return 1;
        else return -1;
    }
}

1406. 石子游戏 III
class Solution {
    public String stoneGameIII(int[] stoneValue) {
        int[] copy=new int[stoneValue.length+2];
        for(int i=0;i<stoneValue.length;i++) copy[i]=stoneValue[i];
        int[] dp=new int[stoneValue.length+3];
        for(int i=stoneValue.length-1;i>=0;i--){
            dp[i]=Math.max(copy[i]+copy[i+1]-dp[i+2],copy[i]+copy[i+1]+copy[i+2]-dp[i+3]);
            dp[i]=Math.max(dp[i],copy[i]-dp[i+1]);
        }
        if(dp[0]>0) return "Alice";
        else if(dp[0]<0) return "Bob";
        else return "Tie";
    }
}

1563. 石子游戏 V
class Solution {
    public int stoneGameV(int[] stoneValue) {
        int n=stoneValue.length;
        int[] prefix=new int[n+1];
        for(int i=1;i<=n;i++) prefix[i]=prefix[i-1]+stoneValue[i-1];

        int[][] dp=new int[n][n];
        for(int i=n-2;i>=0;i--){
            for(int j=i+1;j<n;j++){
                for(int m=i;m<j;m++){
                    int ls=get(prefix,i,m),rs=get(prefix,m+1,j);
                    if(ls==rs){
                        dp[i][j]=Math.max(dp[i][j],ls+Math.max(dp[i][m],dp[m+1][j]));
                    }else if(ls>rs){
                        dp[i][j]=Math.max(dp[i][j],rs+dp[m+1][j]);
                    }else{
                        dp[i][j]=Math.max(dp[i][j],ls+dp[i][m]);
                    }
                }
            }
        }
        return dp[0][n-1];
    }
    public int get(int[] p,int i,int j){
        return p[j+1]-p[i];
    }
}



井字游戏










11、记忆化搜索  本质是 dfs+记忆化，用在状态的转移方向不确定的情况，背后可能是任何一种类型的动态规划

所有线性递推关系都可以用矩阵快速幂做，可以O(logN)，最典型是斐波那契数列
原始递归 //O(2^n)，O(n)   子问题个数乘以解决一个子问题需要的时间   栈大小
记事本 //O(n)，O(n) 空间大小为N的数组
优化DP //O(n)，O(1)
509. 斐波那契数
class Solution {
    public int fib(int N) {
        int[] m=new int[N+1];
        return fibHelp(m,N);
    }
    public int fibHelp(int[] m,int N){
        if(N<2) return N;
        if(m[N]!=0) return m[N];
        m[N]=fibHelp(m,N-1)+fibHelp(m,N-2);
        return m[N];
    }
}

70. 爬楼梯/剑指 Offer 10- II. 青蛙跳台阶问题
class Solution {
    public int climbStairs(int n) {
        int[] m=new int[n+1];
        return climbStairsHelp(m,n);
    }
    public int climbStairsHelp(int[] m,int n){
        if(n<=2) return n;
        if(m[n]!=0) return m[n];
        m[n]=climbStairsHelp(m,n-1)+climbStairsHelp(m,n-2);
        return m[n];
    }
}

class Solution {
    public int climbStairs(int n) {
        if(n<2) return n;
        int[] dp=new int[n+1];
        Arrays.fill(dp,1);
        for(int i=2;i<=n;i++)
            dp[i]=dp[i-1]+dp[i-2];
        return dp[n];
    }
}

139. 单词拆分
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] dp=new boolean[s.length()+1];
        dp[0]=true;
        for(int i=1;i<=s.length();i++){
            for(String word:wordDict){
                if(i>=word.length()&&s.substring(i-word.length(),i).equals(word)) dp[i]=dp[i]||dp[i-word.length()];
            }
        }
        return dp[s.length()];
    }
}


//贪心
392. 判断子序列
//s以i结尾,t以j结尾
class Solution {
    public boolean isSubsequence(String s, String t) {
        int n=s.length(),m=t.length();
        if(n==0) return true;
        if(m==0) return false;
        boolean[][] dp=new boolean[n+1][m+1];
        for(int i=0;i<m;i++) dp[0][i]=true;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(s.charAt(i-1)==t.charAt(j-1)) dp[i][j]=dp[i-1][j-1];
                else dp[i][j]=dp[i][j-1];
            }
        }
        return dp[n][m];
    }
}

514. 自由之路
class Solution {
    int[][] dic;
    Map<Character,List<Integer>> map=new HashMap<>();
    public int findRotateSteps(String ring, String key) {
        dic=new int[ring.length()][key.length()];
        for(int i=0;i<ring.length();i++){
            List<Integer> cur=map.getOrDefault(ring.charAt(i),new ArrayList<>());
            cur.add(i);
            map.put(ring.charAt(i),cur);
        }
        return dp(ring,0,key,0);
    }
    int dp(String ring, int i, String key, int j) {
        if(j==key.length()) return 0;
        if(dic[i][j]!=0) return dic[i][j];

        int res=Integer.MAX_VALUE;
        for(int k:map.get(key.charAt(j))){
            int delta=Math.abs(k-i);
            delta=Math.min(delta,ring.length()-delta);
            res=Math.min(res,1+delta+dp(ring,k,key,j+1));
        }
        dic[i][j]=res;
        return res;
    }
}

class Solution {
    public int findRotateSteps(String ring, String key) {
        Map<Character,List<Integer>> map=new HashMap<>();
        for(int i=0;i<ring.length();i++){
            List<Integer> cur=map.getOrDefault(ring.charAt(i),new ArrayList<>());
            cur.add(i);
            map.put(ring.charAt(i),cur);
        }
        int[][] dp=new int[key.length()][ring.length()];
        for(int[] d:dp) Arrays.fill(d, Integer.MAX_VALUE);
        for(int i=0;i<key.length();i++){
            for(int j:map.get(key.charAt(i))){
                if(i==0) dp[i][j]=Math.min(dp[i][j],getStep(ring.length(),0,j)+1);
                else{
                    for(int k:map.get(key.charAt(i-1))){
                        dp[i][j]=Math.min(dp[i][j],dp[i-1][k]+getStep(ring.length(),k,j)+1);
                    }
                }
            }
        }
        return Arrays.stream(dp[key.length()-1]).min().getAsInt();
    }
    public int getStep(int n,int i,int j){
        int delta=Math.abs(j-i);
        return Math.min(delta,n-delta);
    }
}





//https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md#
信件错排  有N个信和信封, 它们被打乱, 求错误装信方式的数量。
dp[i][j]=(i-1)*dp[i-2] + (i-1)*dp[i-1]

母牛生产  母牛每年都会生1头小母牛, 第一年有1只小母牛, 从第二年开始, 母牛开始生小母牛. 每只小母牛3年之后成熟又可以生小母牛. 求N年后牛的数量.
//去年母牛+元母牛产的1+成熟母牛产的1
dp[i]=dp[i-1]+dp[i-3]




13、其它
二分优化DP
887. 鸡蛋掉落
//X层扔鸡蛋, i个鸡蛋j层楼最少实验次数, max(碎dp[K-1][X-1], 没碎dp[K][N-X])+1
class Solution {
    public int superEggDrop(int K, int N) {
        int[][] dp=new int[K+1][N+1];
        for(int[] d:dp) Arrays.fill(d,N);
        for(int i=0;i<=K;i++) dp[i][0]=0;
        for(int i=1;i<=K;i++) dp[i][1]=1;
        for(int i=0;i<=N;i++) {
            dp[0][i]=0;
            dp[1][i]=i;
        }

        for(int i=2;i<=K;i++){
            for(int j=2;j<=N;j++){
                for(int k=1;k<=j;k++){
                    dp[i][j]=Math.min(dp[i][j],Math.max(dp[i-1][k-1],dp[i][j-k])+1);
                }
            }
        }
        return dp[K][N];
    }
}

//k枚举了扔下鸡蛋的楼层的高度, k越大, 碎则检测次数变大，而不碎检测次数减小dp[i-1][k-1]越大, dp[i][j-k]越小, 要取两数最大值且最小化
class Solution {
    public int superEggDrop(int K, int N) {
        int[][] dp=new int[K+1][N+1];
        for(int[] d:dp) Arrays.fill(d,N);
        for(int i=0;i<=K;i++) dp[i][0]=0;
        for(int i=1;i<=K;i++) dp[i][1]=1;
        for(int i=0;i<=N;i++) {
            dp[0][i]=0;
            dp[1][i]=i;
        }

        for(int i=2;i<=K;i++){
            for(int j=2;j<=N;j++){
                int l=1,r=j;
                while(l<r){
                    int m=l+((r-l)>>>1);
                    if(dp[i-1][m-1]<dp[i][j-m]) l=m+1;
                    else r=m;
                }
                dp[i][j]=Math.max(dp[i-1][l-1],dp[i][j-l])+1;
            }
        }
        return dp[K][N];
    }
}

//K个鸡蛋, 最多操作j次, 求N最大值
class Solution {
    public int superEggDrop(int K, int N) {
        int[][] dp=new int[K+1][N+1];
        int j=0;
        while(dp[K][j]<N){
            j++;
            for(int i=1;i<=K;i++) dp[i][j]=dp[i-1][j-1]+1+dp[i][j-1];//碎可以多检测一层, 没碎只能检测当前层
        }
        return j;
    }
}